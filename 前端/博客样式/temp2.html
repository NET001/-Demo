<div id="title1">
    <h1 style="text-align: left;">什么是反射</h1>
    <p style="text-align: left;">可以动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。 然后，可以调用类型的方法或访问其字段和属性</p>
    <h1>C#中的反射</h1>
    <p>使用 Assembly 来定义和加载程序集，加载程序集清单中列出的模块，以及在此程序集中定位一个类型并创建一个它的实例。</p>
    <p>使用 Module 发现信息，如包含模块的程序集和模块中的类。 还可以获取所有全局方法或模块上定义的其它特定的非全局方法。</p>
    <p>使用 ConstructorInfo 发现信息，如名称、参数、访问修饰符（如 public 或 private）和构造函数的实现详细信息（如 abstract 或 virtual）。 使用 Type 的 GetConstructors 或 GetConstructor 方法来调用特定构造函数。</p>
    <p>使用 MethodInfo 发现信息，如名称、返回类型、参数、访问修饰符（如 public 或 private）和方法的实现详细信息（如 abstract 或 virtual）。 使用 Type 的 GetMethods 或 GetMethod 方法来调用特定方法。</p>
    <p>使用 FieldInfo 发现信息，如名称、访问修饰符（如 public 或 private）和一个字段的实现详细信息 （如 static）；并获取或设置字段值。</p>
    <p>使用 EventInfo 发现信息（如名称、事件处理程序的数据类型、自定义特性、声明类型以及事件的反射的类型），并添加或删除事件处理程序。</p>
    <p>使用 PropertyInfo 发现信息（如名称、数据类型、声明类型，反射的类型和属性的只读或可写状态），并获取或设置属性值。</p>
    <p>使用 ParameterInfo 发现信息，如参数的名称、数据类型、参数是输入参数还是输出参数以及参数在方法签名中的位置。</p>
    <p>使用 CustomAttributeData 在于应用程序域的仅反射上下文中工作时发现有关自定义特性的信息。 CustomAttributeData 使你能够检查特性，而无需创建它们的实例。 System.Reflection.Emit 命名空间的类提供一种专用形式的反射，使你能够在运行时生成类型。</p>
    <p>[官方文档](https://docs.microsoft.com/zh-cn/dotnet/framework/reflection-and-codedom/reflection)</p>
    <h1>反射的优点</h1>
    <p>提高了程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无需提前硬编码目标类</p>
    <h1>反射的运用场景</h1>
    <p>在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息</p>
    <p>用于系统架构设计</p>
    <h1>反射的问题</h1>
    <p>性能问题:反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码,因此反射机制主要应用于对灵活性和扩展性要求很高的系统框架上,主要偏向于系统底层设计</p>
    <p>使用反射会模糊程序内部逻辑,程序员希望在代码中看到程序逻辑,反射则绕过了源代码的技术,因而会带来维护和调试的问题,反射的代码相比于直接代码要更加复杂</p>
    </div>